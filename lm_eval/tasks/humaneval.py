"""
"Evaluating Large Language Models Trained on Code"
https://arxiv.org/abs/2107.03374
TODO: add abstract/description
Homepage: https://github.com/openai/human-eval
"""
import re
import os
import json
import numpy as np
from lm_eval.base import Task, rf
from lm_eval.metrics import mean
from lm_eval.datasets.humaneval.data import (
    stream_jsonl,
    PATH_TO_HUMANEVAL,
    PATH_TO_HUMANEVAL_DATA,
    HUMAN_EVAL,
)

_CITATION = """
@article{chen2021codex,
  title={Evaluating Large Language Models Trained on Code},
  author={Mark Chen and Jerry Tworek and Heewoo Jun and Qiming Yuan and Henrique Ponde de Oliveira Pinto and Jared Kaplan and Harri Edwards and Yuri Burda and Nicholas Joseph and Greg Brockman and Alex Ray and Raul Puri and Gretchen Krueger and Michael Petrov and Heidy Khlaaf and Girish Sastry and Pamela Mishkin and Brooke Chan and Scott Gray and Nick Ryder and Mikhail Pavlov and Alethea Power and Lukasz Kaiser and Mohammad Bavarian and Clemens Winter and Philippe Tillet and Felipe Petroski Such and Dave Cummings and Matthias Plappert and Fotios Chantzis and Elizabeth Barnes and Ariel Herbert-Voss and William Hebgen Guss and Alex Nichol and Alex Paino and Nikolas Tezak and Jie Tang and Igor Babuschkin and Suchir Balaji and Shantanu Jain and William Saunders and Christopher Hesse and Andrew N. Carr and Jan Leike and Josh Achiam and Vedant Misra and Evan Morikawa and Alec Radford and Matthew Knight and Miles Brundage and Mira Murati and Katie Mayer and Peter Welinder and Bob McGrew and Dario Amodei and Sam McCandlish and Ilya Sutskever and Wojciech Zaremba},
  year={2021},
  eprint={2107.03374},
  archivePrefix={arXiv},
  primaryClass={cs.LG}
}
"""


class HumanEval(Task):
    VERSION = 0
    DATASET_PATH = "openai_humaneval"
    DATASET_NAME = None

    os.makedirs(PATH_TO_HUMANEVAL_DATA, exist_ok=True)
    if os.path.isfile(f"{PATH_TO_HUMANEVAL_DATA}/samples.jsonl"):
        os.remove(f"{PATH_TO_HUMANEVAL_DATA}/samples.jsonl")
    if os.path.isfile(f"{PATH_TO_HUMANEVAL_DATA}/samples.jsonl_results.jsonl"):
        os.remove(f"{PATH_TO_HUMANEVAL_DATA}/samples.jsonl_results.jsonl")

    def set_num_answers_per_example(self, num_answers_per_example):
        self.num_answers_per_example = num_answers_per_example

    def has_training_docs(self):
        return False

    def has_validation_docs(self):
        return False

    def has_test_docs(self):
        return True

    def training_docs(self):
        raise NotImplementedError

    def validation_docs(self):
        raise NotImplementedError

    def test_docs(self):
        self.dataset["test"].to_json(HUMAN_EVAL)
        return self.dataset["test"]

    def doc_to_text(self, doc):
        return doc["prompt"]

    def doc_to_target(self, doc):
        return None

    def construct_requests(self, doc, ctx):
        """Uses RequestFactory to construct Requests and returns an iterable of
        Requests which will be sent to the LM.
        :param doc:
            The document as returned from training_docs, validation_docs, or test_docs.
        :param ctx: str
            The context string, generated by fewshot_context. This includes the natural
            language description, as well as the few shot examples, and the question
            part of the document for `doc`.
        """
        completion = [rf.greedy_until(ctx, {"until": ["\n\n"]}) for _ in range(self.num_answers_per_example)]
        return completion

    def _is_correct(self, completion, doc):
        results = []
        for sample in stream_jsonl(f"{PATH_TO_HUMANEVAL_DATA}/samples.jsonl_results.jsonl"):
            task_id = sample["task_id"]
            if task_id == doc["task_id"]:
                results.append(sample["passed"])

        total = len(results)
        correct = sum(results)

        pass_at_k = {f"pass@{k}": self.estimate_pass_at_k(total, correct, k)
                 for k in [1, 10, 100] if total >= k}
        return pass_at_k

    def process_results(self, doc, results):
        """Take a single document and the LM results and evaluates, returning a
        dict where keys are the names of submetrics and values are the values of
        the metric for that one document
        :param doc:
            The document as returned from training_docs, validation_docs, or test_docs.
        :param results:
            The results of the requests created in construct_requests.
        """
        # log outputs to a jsonl file, for use with the official evaluation + execution script.
        with open(f"{PATH_TO_HUMANEVAL_DATA}/samples.jsonl", "a") as file:
            for completion in results:
                completion = self.extract_code_and_imports_as_string(completion)
                file.write(json.dumps({"task_id": doc["task_id"], "completion": completion}) + "\n")
        tmp = os.popen(f"python {PATH_TO_HUMANEVAL}/evaluate_functional_correctness.py {PATH_TO_HUMANEVAL_DATA}/samples.jsonl").read()
        return self._is_correct(completion, doc)

    def aggregation(self):
        """
        :returns: {str: [float] -> float}
            A dictionary where keys are the names of submetrics and values are
            functions that aggregate a list of metrics
        """
        return {"pass@1": mean, "pass@10": mean, "pass@100": mean}

    def higher_is_better(self):
        """
        :returns: {str: bool}
            A dictionary where keys are the names of submetrics and values are
            whether a higher value of the submetric is better
        """
        return {f"pass@{k}": True for k in [1, 10, 100]}

    def remove_empty_lines(self, code):
        lines = code.split('\n')
        non_empty_lines = [line for line in lines if line.strip() != '']
        return '\n'.join(non_empty_lines)

    def extract_code_and_imports_as_string(self, llama_output):
        llama_output = llama_output.replace('```', '')
        llama_output = self.remove_empty_lines(llama_output)
        blocks = re.split(r'\n\n|\n(?=def |class )', llama_output)
        code_blocks = []
        imports = []

        for block in blocks:
            lines = block.split('\n')
            current_code_block = []
            in_code_block = False

            for line in lines:
                line_stripped = line.strip()

                if line_stripped.startswith('import ') or line_stripped.startswith('from '):
                    imports.append(line_stripped)

                if line_stripped.startswith('def ') or line_stripped.startswith('class '):
                    # Start of a new code block
                    in_code_block = True
                    current_code_block.append(line)

                elif in_code_block:
                    # Collect lines belonging to the current code block
                    current_code_block.append(line)

            # Add the current code block if present
            if current_code_block:
                code_blocks.append('\n'.join(current_code_block))

        code_blocks_str = "\n\n".join(code_blocks) if code_blocks else ""
        imports_str = "\n".join(imports) if imports else ""
        try:
            code_idx_end = [i for i in range(len(code_blocks_str)) if code_blocks_str.startswith('    return', i)][-1]
            while (code_blocks_str[code_idx_end] != '\n') and (code_idx_end < len(code_blocks_str) - 1):
                code_idx_end += 1
            code_blocks_str = code_blocks_str[:code_idx_end + 1]
        except IndexError:
            pass

        if imports_str and code_blocks_str:
            return f"\n{imports_str}\n\n\n{code_blocks_str}"
        elif imports_str:
            return f"Imports:\n{imports_str}"
        elif code_blocks_str:
            return f"\n{code_blocks_str}"
        else:
            return "No code blocks found in the response."

    def estimate_pass_at_k(self, n, c, k):
        """
        Calculates 1 - comb(n - c, k) / comb(n, k).
        """
        if n - c < k:
            return 1.0
        return 1.0 - np.prod(1.0 - k / np.arange(n - c + 1, n + 1))
